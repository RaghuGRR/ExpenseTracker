package com.android.expensetracker.features.expense_entry

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.android.domain.model.Expense
import com.android.domain.usecase.ExpenseUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import java.util.Calendar
import javax.inject.Inject

@HiltViewModel
class ExpenseEntryViewModel @Inject constructor(
    private val expenseUseCase: ExpenseUseCase
) : ViewModel() {

    private val _title = MutableStateFlow("")
    val title: StateFlow<String> = _title.asStateFlow()

    private val _amount = MutableStateFlow("")
    val amount: StateFlow<String> = _amount.asStateFlow()

    private val _category = MutableStateFlow("")
    val category: StateFlow<String> = _category.asStateFlow()

    private val _notes = MutableStateFlow("")
    val notes: StateFlow<String> = _notes.asStateFlow()

    private val _receiptImageUri = MutableStateFlow<String?>(null) // Retaining for completeness
    val receiptImageUri: StateFlow<String?> = _receiptImageUri.asStateFlow()

    // For UI events like showing a Toast
    private val _uiEvents = MutableStateFlow<UiEvent?>(null)
    val uiEvents: StateFlow<UiEvent?> = _uiEvents.asStateFlow()

    val totalSpentToday: StateFlow<Double> =
        expenseUseCase.getTotalForDateRange(getStartOfToday(), getEndOfToday())
            .map { it ?: 0.0 } // Default to 0.0 if null from use case
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = 0.0
            )

    fun onTitleChange(newTitle: String) {
        _title.value = newTitle
    }

    fun onAmountChange(newAmount: String) {
        _amount.value = newAmount
    }

    fun onCategoryChange(newCategory: String) {
        _category.value = newCategory
    }

    fun onNotesChange(newNotes: String) {
        _notes.value = newNotes
    }

    fun onReceiptImageSelected(uriString: String?) { // Retaining for completeness
        _receiptImageUri.value = uriString
    }

    fun addExpense() {
        val titleValue = _title.value.trim()
        val amountValueString = _amount.value.trim()
        val categoryValue = _category.value

        if (titleValue.isBlank()) {
            triggerUiEvent(UiEvent.ShowToast("Title cannot be empty"))
            return
        }

        val amountDouble = amountValueString.toDoubleOrNull()
        if (amountDouble == null || amountDouble <= 0) {
            triggerUiEvent(UiEvent.ShowToast("Please enter a valid amount greater than 0"))
            return
        }

        if (categoryValue.isBlank()) {
            triggerUiEvent(UiEvent.ShowToast("Please select a category"))
            return
        }

        viewModelScope.launch {
            try {
                expenseUseCase.addExpense(
                    Expense(
                        // id will be auto-generated by Room
                        title = titleValue,
                        amount = amountDouble,
                        category = categoryValue,
                        notes = _notes.value.trim(),
                        date = System.currentTimeMillis(), // Current time for the expense
                        receiptImageUri = _receiptImageUri.value // Retaining for completeness
                    )
                )
                triggerUiEvent(UiEvent.ShowToast("Expense added successfully"))
                clearInputFields()
            } catch (e: Exception) {
                // Log the exception e.g. Timber.e(e, "Error adding expense")
                triggerUiEvent(UiEvent.ShowToast("Error adding expense: ${e.localizedMessage ?: "Unknown error"}"))
            }
        }
    }

    private fun clearInputFields() {
        _title.value = ""
        _amount.value = ""
        // _category.value = "" // User might want to keep the category for next entry
        _notes.value = ""
        _receiptImageUri.value = null // Retaining for completeness
    }

    private fun getStartOfToday(): Long {
        return Calendar.getInstance().apply {
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }.timeInMillis
    }

    private fun getEndOfToday(): Long {
        return Calendar.getInstance().apply {
            set(Calendar.HOUR_OF_DAY, 23)
            set(Calendar.MINUTE, 59)
            set(Calendar.SECOND, 59)
            set(Calendar.MILLISECOND, 999)
        }.timeInMillis
    }
    
    fun consumeUiEvent() {
        _uiEvents.value = null
    }

    private fun triggerUiEvent(event: UiEvent) {
        // We don't need a new coroutine for just setting a MutableStateFlow value
        // but if there were other suspend functions here, launch would be appropriate.
        _uiEvents.value = event 
    }
}

// Sealed class for UI Events, place in its own file if it grows
sealed class UiEvent {
    data class ShowToast(val message: String) : UiEvent()
    // Add other events here, e.g., Navigate, ShowSnackbar
}
